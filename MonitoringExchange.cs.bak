using System;
using System.Collections.Generic;
using System.Linq;
using Deltix.EMS.API;
using Deltix.Timebase.Api.Messages;
using IdxEditor.Rendering;
using IdxEditor.Rendering.Attributes;
using QuantOffice.Execution;


public class MonitoringExchange
{
    private StrategyTimer CheckLastMessageTimer = null;

    public MonitoringExchange(ExchangeParameters parameters, PortfolioExecutor portfolioExecutor)
    {
        PortfolioExecutor = portfolioExecutor;

        Running = false;
        Name = parameters.Name;
        ExchangeParameters = parameters;
        ExchangeSymbols = new Dictionary<string, ExchangeSymbol>();
        foreach (var symbol in Utils.GetListFromLine(ExchangeParameters.Symbols))
        {
            ExchangeSymbols.Add(symbol, new ExchangeSymbol(symbol, this));
        }
    }

    public readonly PortfolioExecutor PortfolioExecutor;
    public string Name { get; set; }
    public bool Running { get; set; }
    public ExchangeParameters ExchangeParameters;
    public Dictionary<string, ExchangeSymbol> ExchangeSymbols;

    public void Activate()
    {
        if (Running)
            return;
        Running = true;

        if (PortfolioExecutor.IsEnabledLog)
            PortfolioExecutor.Log("Activate " + Name + " exchange");
        foreach (InstrumentExecutor instr in PortfolioExecutor.Slice)
        {
            if (ExchangeSymbols.Keys.Contains(instr.Symbol.ToString()))
            {
                try
                {
                    instr.OrderBook.GetExchangeOrderBook(ExchangeCodec.CodeToLong(Name)).AddOnBestChangedListener(instr.OnBestChannged);
                }
                catch (Exception ex)
                {
                    PortfolioExecutor.Log(instr.Symbol + "; Message:" + ex.Message + " " + ex.StackTrace);
                }
            }
        }
    }

    public void Deactivate()
    {
        if (!Running)
            return;

        if (PortfolioExecutor.IsEnabledLog)
            PortfolioExecutor.Log("Deactivate: " + Name + " exchange");
        foreach (InstrumentExecutor instr in PortfolioExecutor.Slice)
        {
            if (ExchangeSymbols.Keys.Contains(instr.Symbol.ToString()))
            {
                try
                {
                    instr.OrderBook.GetExchangeOrderBook(ExchangeCodec.CodeToLong(Name)).RemoveOnBestChangedListener(instr.OnBestChannged);
                    instr.workExchangesOrders.Remove(Name);
                }
                catch (Exception ex)
                {
                    PortfolioExecutor.Log(instr.Symbol + "; Message:" + ex.Message + " " + ex.StackTrace);
                }
            }
        }
        Running = false;
    }

    public void UpdateStatus(DateTime newTime, string symbol)
    {
        ExchangeSymbols[symbol].UpdateStatus(newTime);
    }

    public void RemoveSymbolsForOrders(string symbol, SentOrderStatus status)
    {
        ExchangeSymbols[symbol].LastOrderStatus.Status = status;
        ExchangeSymbols[symbol].StopSendingOrders();
        ExchangeParameters.SymbolsForOrders = Utils.GetLineFromList(ExchangeSymbols.Values.Where(e => e.IsSendOrders).Select(e => e.Name).ToList());
    }

    public void UpdateSymbols()
    {
        if (Running == false)
        {
            foreach (var symbol in ExchangeSymbols.Select(s => s.Value))
            {
                symbol.Deactivate();
            }
            return;
        }

        var paramSymbols = Utils.GetListFromLine(ExchangeParameters.Symbols);

        var addSymbols = paramSymbols.Except(ExchangeSymbols.Select(s => s.Value).Where(s => s.IsActivate()).Select(s => s.Name)).ToList();
        var removeSymbols = ExchangeSymbols.Keys.Except(paramSymbols).ToList();

        foreach (var symbol in removeSymbols)
        {
            ExchangeSymbols[symbol].Deactivate();
            ExchangeSymbols.Remove(symbol);
            PortfolioExecutor.RemoveSymbol(symbol);
        }

        foreach (var symbol in addSymbols)
        {
            if (!ExchangeSymbols.ContainsKey(symbol))
            {
                PortfolioExecutor.AddSymbol(symbol);
                ExchangeSymbols.Add(symbol, new ExchangeSymbol(symbol, this));
            }
            ExchangeSymbols[symbol].Activate();
        }
    }

    public void UpdateSymbolsForOrders()
    {
        if (Running == false)
        {
            return;
        }

        var paramSymbols = Utils.GetListFromLine(ExchangeParameters.SymbolsForOrders).Union(ExchangeSymbols.Keys).ToList();

        var addSymbols = paramSymbols.Except(ExchangeSymbols.Values.Where(s => s.IsSendOrders).Select(e => e.Name).ToList());
        var removeSymbols = ExchangeSymbols.Values.Where(s => s.IsSendOrders).Select(s => s.Name).Except(paramSymbols).ToList();

        foreach (var symbol in removeSymbols)
        {
            ExchangeSymbols[symbol].StopSendingOrders();
        }

        foreach (var symbol in addSymbols)
        {
            ExchangeSymbols[symbol].StartSendingOrders();
        }

        foreach (InstrumentExecutor instr in PortfolioExecutor.Slice)
        {
            if (addSymbols.Contains(instr.Symbol.ToString()))
            {
                instr.workExchangesOrders.Add(Name, this);
                instr.StartSendingOrders();
            }

            if (removeSymbols.Contains(instr.Symbol.ToString()))
                instr.workExchangesOrders.Remove(Name);
        }
        
        ExchangeParameters.SymbolsForOrders = Utils.GetLineFromList(ExchangeSymbols.Values.Where(s => s.IsSendOrders).Select(s => s.Name).ToList());
    }

    #region Print

    public string GetLastMessageTime()
    {
        DateTime lastTime = DateTime.MinValue;
        foreach(var symbol in ExchangeSymbols.Values)
            if (symbol.LastMessageTime > lastTime)
                lastTime = symbol.LastMessageTime;
        if(lastTime == DateTime.MinValue)
            return "";
        else if ((DateTime.Now - lastTime).TotalSeconds > PortfolioExecutor.WaitInterval)
            return "Data on exchange have ceased";
        return Utils.TimeInString(lastTime.ToUniversalTime());
    }

    public string GetFilledOrdersOnSymbols()
    {
        string result = "";
        foreach (var symbol in ExchangeSymbols.Values)
        {
            if(symbol.LastOrderStatus.Status == SentOrderStatus.NORMAL && symbol.LastOrderStatus.CountFilledOrders > 0)
                result += symbol.Name + ": " + symbol.LastOrderStatus.CountFilledOrders + "; ";
            if (symbol.LastOrderStatus.Status == SentOrderStatus.REJECT)
                result += symbol.Name + ": REJECT; ";
            if (symbol.LastOrderStatus.Status == SentOrderStatus.NOT_RESPONDING)
                result += symbol.Name + ": NOT RESPONDING; ";
        }

        return result == "" ? "" : result.Substring(0, result.Length - 2);
    }

    public string GetOrderBookStatus()
    {
        string result = "";
        foreach (var symbol in ExchangeSymbols)
        {
            if (symbol.Value.SpreadObserver.Status == SpreadStatus.CROSS)
                result += symbol.Key + ": Negative spread at " + symbol.Value.SpreadObserver.LastErrorTime + "; ";
            if (symbol.Value.SpreadObserver.Status == SpreadStatus.EMPTY_SIDE)
                result += symbol.Key + ": Empty side at " + symbol.Value.SpreadObserver.LastErrorTime + "; ";
        }

        return result == "" ? "" : result.Substring(0, result.Length - 2);
    }

    #endregion

    #region Orders statuses

    public void UpdateOrderStatus(string symbol, long id)
    {
        ExchangeSymbols[symbol].LastOrderStatus.LastFilledTime = DateTime.UtcNow;
        ExchangeSymbols[symbol].LastOrderStatus.CountFilledOrders++;
        ExchangeSymbols[symbol].LastOrderStatus.LastSentOrderId = ExchangeSymbols[symbol].LastOrderStatus.LastSentOrderId == id ? 0 : ExchangeSymbols[symbol].LastOrderStatus.LastSentOrderId;
    }

    public bool CheckFillLastOrder(string symbol, DateTime currentTime)
    {
        long orderId = ExchangeSymbols[symbol].LastOrderStatus.LastSentOrderId;
        if (orderId != 0)
        {
            Order order = PortfolioExecutor.orderProcessor.GetOrderData(orderId);
            string textForReport = String.Format("Order id: {0}.\r\nSubmission Time: {1}.\r\nCurrentTime: {2}.",
                orderId, order.SubmissionTime, currentTime);
            if (PortfolioExecutor.IsEnabledLog)
                PortfolioExecutor.Log(Name + "/" + symbol + ": Order is not responding; Id = " + orderId);
            PortfolioExecutor.EMailSender.Send(Name + "/" + symbol + ": Order is not responding", textForReport);
            return false;
        }

        return true;
    }

    #endregion
}

[Serializable]
public sealed class ExchangeParameters : Parameters<ExchangeParameters>
{
    #region Variables

    [EditableInRuntime]
    [DisplayInfo(DisplayName = "Activate?")]
    public bool IsActivate;

    [EditableInRuntime]
    [DisplayInfo(DisplayName = "Name")]
    public string Name;

    [EditableInRuntime]
    [DisplayInfo(DisplayName = "Input the list of Symbols")]
    public string Symbols;

    [EditableInRuntime]
    [DisplayInfo(DisplayName = "Input the list of Symbols for sending orders:")]
    public string SymbolsForOrders;

    [EditableInRuntime]
    [DisplayInfo(DisplayName = "Allow one side of book?")]
    public bool IsAllowOneSide;

    [EditableInRuntime]
    [DisplayInfo(DisplayName = "Interval of duration of cross (sec)")]
    public int MaxCrossInterval;

    #endregion

    #region BuildingBlocks

    public ExchangeParameters(string name, bool isActivate, string symbols, string symbolsForOrders, int maxCross, bool isOneSide)
    {
        Name = name;
        IsActivate = isActivate;
        Symbols = symbols;
        SymbolsForOrders = symbolsForOrders;
        MaxCrossInterval = maxCross;
        IsAllowOneSide = isOneSide;
    }

    public ExchangeParameters(string name, bool isActivate, string symbols, string symbolsForOrders)
    {
        Name = name;
        IsActivate = isActivate;
        Symbols = symbols;
        SymbolsForOrders = symbolsForOrders;
        IsAllowOneSide = false;
        MaxCrossInterval = 0;
    }

    public ExchangeParameters()
    {
        Name = "";
        IsActivate = false;
        Symbols = "";
        SymbolsForOrders = "";
        IsAllowOneSide = false;
        MaxCrossInterval = 0;
    }

    internal override void CopyDataFrom(ExchangeParameters source)
    {
        if (source == null)
        {
            throw new ArgumentNullException("source");
        }

        Name = source.Name;
        IsActivate = source.IsActivate;
        Symbols = source.Symbols;
        SymbolsForOrders = source.SymbolsForOrders;
    }

    internal override string ToString(string prefix)
    {
        return String.Format("Exchange: {0}; Activate? {1}, List of Symbols: {2}, List of Symbols for sending orders: {3}", Name, IsActivate, Symbols, SymbolsForOrders);
    }

    #endregion
}
